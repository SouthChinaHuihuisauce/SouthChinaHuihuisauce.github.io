import{W as y,x as m,L as C,X as _,Y as w,T as v,C as b,Z as O,$ as x,f as k,a0 as A,a1 as B,a2 as H}from"./entry.b2448997.js";const M=()=>null;function R(...i){const r=typeof i[i.length-1]=="string"?i.pop():void 0;typeof i[0]!="string"&&i.unshift(r);let[a,u,t={}]=i;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");t.server=t.server??!0,t.default=t.default??M,t.lazy=t.lazy??!1,t.immediate=t.immediate??!0;const e=y(),f=()=>e.isHydrating?e.payload.data[a]:e.static.data[a],c=()=>f()!==void 0;e._asyncData[a]||(e._asyncData[a]={data:m(f()??t.default()),pending:m(!c()),error:C(e.payload._errors,a)});const n={...e._asyncData[a]};n.refresh=n.execute=(o={})=>{if(e._asyncDataPromises[a]){if(o.dedupe===!1)return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if((o._initial||e.isHydrating&&o._initial!==!1)&&c())return f();n.pending.value=!0;const d=new Promise((s,l)=>{try{s(u(e))}catch(P){l(P)}}).then(s=>{if(d.cancelled)return e._asyncDataPromises[a];let l=s;t.transform&&(l=t.transform(s)),t.pick&&(l=j(l,t.pick)),n.data.value=l,n.error.value=null}).catch(s=>{if(d.cancelled)return e._asyncDataPromises[a];n.error.value=s,n.data.value=O(t.default())}).finally(()=>{d.cancelled||(n.pending.value=!1,e.payload.data[a]=n.data.value,n.error.value&&(e.payload._errors[a]=x(n.error.value)),delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=d,e._asyncDataPromises[a]};const h=()=>n.refresh({_initial:!0}),g=t.server!==!1&&e.payload.serverRendered;{const o=_();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const s=o._nuxtOnBeforeMountCbs;o&&(w(()=>{s.forEach(l=>{l()}),s.splice(0,s.length)}),v(()=>s.splice(0,s.length)))}g&&e.isHydrating&&c()?n.pending.value=!1:o&&(e.payload.serverRendered&&e.isHydrating||t.lazy)&&t.immediate?o._nuxtOnBeforeMountCbs.push(h):t.immediate&&h(),t.watch&&b(t.watch,()=>n.refresh());const d=e.hook("app:data:refresh",s=>{if(!s||s.includes(a))return n.refresh()});o&&v(d)}const p=Promise.resolve(e._asyncDataPromises[a]).then(()=>n);return Object.assign(p,n),p}function j(i,r){const a={};for(const u of r)a[u]=i[u];return a}const D="__nuxt_component";async function E(i,r){const a=y(),u=A(),t=_(),{fetchKey:e}=t.proxy.$options,f=typeof e=="function"?e(()=>""):e||u.fullPath,{data:c,error:n}=await R(`options:asyncdata:${f}`,()=>a.runWithContext(()=>r(a)));if(n.value)throw x(n.value);c.value&&typeof c.value=="object"&&Object.assign(await i,B(H(c.value)))}const z=function(r){const{setup:a}=r;return!a&&!r.asyncData&&!r.head?{[D]:!0,...r}:{[D]:!0,...r,setup(u,t){const e=y(),f=a?Promise.resolve(e.runWithContext(()=>a(u,t))).then(n=>n||{}):{},c=[];if(r.asyncData&&c.push(E(f,r.asyncData)),r.head){const n=y();k(typeof r.head=="function"?()=>r.head(n):r.head)}return Promise.resolve(f).then(()=>Promise.all(c)).then(()=>f).finally(()=>{c.length=0})}}};export{z as d};
